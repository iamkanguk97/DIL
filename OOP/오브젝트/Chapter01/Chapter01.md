# 챕터1: 객체, 설계

## 소프트웨어 모듈이 가져야 하는 3가지 기능

> `모듈(Module)`: 크기와 상관없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 요소

-   **실행중에 제대로 동작하는 것** -> 모듈의 존재 이유
-   **변경을 위해 존재하는 것** -> 대부분의 모듈은 생명주기동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야함 -> 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 합니다.
-   **코드를 읽는 사람과 의사소통하는 것** -> 모듈은 특별한 훈련 없어도 개발자가 쉽게 읽고 이해할 수 있어야 합니다.

## Theater 클래스의 문제점

> [Theater.ts](./example_1/ts/Theater.ts) 를 살펴보겠습니다.

-   문제점은 `관람객(Audience)`과 `판매원(TicketSeller)`는 `소극장(Theater)`의 **통제를 받는 수동적인 존재**라는 점입니다.
-   지금 현 상황은 소극장이라는 제3자가 초대장을 확인하기 위해서 관람객의 가방을 마음대로 열어본다는 것입니다. 당연히 문제가 될 부분입니다.
-   **이해 가능한 코드는 동작이 우리의 예상에서 크게 벗어나지 않는 코드입니다.**
-   현실은 관람객은 가방 안에서 직접 돈을 꺼내서 판매원에게 지불하고 판매원은 매표소에 있는 티켓을 꺼내서 관람객에게 건네고 관람객에게 직접 돈을 받아서 매표소에 보관합니다.
-   **그리고, 해당 코드를 이해하기 위해서는 여러 세부적인 내용들을 기억하고 있어야 한다는 문제점이 있습니다.**
    -   `enter` 메서드에는 Audience가 Bag를 가지고 있고, Bag에는 현금과 티켓이 있고, TicketSeller가 TicketOffice에서 티켓을 판매하는 등의 정보들을 전부 기억하고 있어야 합니다.
-   **마지막으로는, Audience와 TicketSeller를 변경할 경우 Theater도 같이 변경해야 한다는 단점이 있습니다.**
    -   해당 코드에서는 관람객이 가방을 항상 들고다닌다고 가정하고, 현금을 쓴다고 가정하고 등등의 제약사항이 있습니다.
    -   만약 관람객이 가방을 안들고오거나 카드가 아닌 신용카드를 쓴다면?
    -   이는 **객체 사이의 의존성(Dependency)**와 관련된 문제입니다. 의존성은 변경과 관련되어 있습니다.
-   **객체 사이의 의존성을 무작정 없애는 것은 정답이 아닙니다. 객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이기 때문에 필요한 최소한의 의존성만 유지하는 것이 중요합니다.**

## 결합도(Coupling)

-   객체 사이에 의존성이 너무 강하면 결합도가 높다고 말합니다. 결합도는 의존성과 관련되어 있습니다.
-   두 객체 사이의 결합도가 높을수록 함께 변경될 확률이 높아지기 때문에 변경에 어려움을 느낍니다.
-   따라서, 설계의 목표는 객체 사이의 결합도를 낮춰서 변경이 용이한 설계를 만들어야 합니다.
