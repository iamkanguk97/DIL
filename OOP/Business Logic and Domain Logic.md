# 비즈니스 로직과 도메인 로직 그리고 Application Service 로직.. 이게 도대체 뭘까? 이해가 너무 안돼..

> 해당 DIL은 [비즈니스 로직, 도메인 로직이 도대체 뭐지?](https://velog.io/@eddy_song/domain-logic) 라는 포스팅을 적극적으로 참고했습니다.

## 서론

프레임워크 없이 바닐라JS로 Node.js HTTP 서버를 구현하고 있고 평소 객체지향을 열심히 학습하는 나로서는 비즈니스 로직과 도메인 로직 등에 대해서 관심이 많이 가는 것 같습니다. 심지어 본인이 이런 용어들에 대해서 무지하고 있었다는 것입니다. 마침 좋은 글을 발견해서 참고해서 정리를 해보려고 합니다.

"비즈니스 로직을 분리하세요!", "비즈니스 로직은 다른 계층에 의존해서는 안됩니다!" 라는 말은 어느 곳에서든 몇번 들었던 것 같습니다. 뭔가 느낌은 알 것 같은데.. 확 와닿는 건 지금 이 글을 쓰는 시점에도 없는 것 같습니다.

지금부터는 이에 대한 정리를 해보겠습니다.

## 도메인과 비즈니스

도메인과 비즈니스는 소프트웨어 공학에서 `소프트웨어가 풀고자하는 현실 세상의 문제`를 의미합니다. 거의 동의어처럼 쓰이고 있습니다. 즉, `소프트웨어가 존재하는 이유, 목적`을 의미합니다.

예를 들어, 은행 애플리케이션이면 금융/은행 업무가 도메인(비즈니스)입니다. 은행 애플리케이션이 해결하고자 하는 문제는 금융 업무를 오프라인이 아닌 온라인(스마트폰)에서 처리할 수 있게 하는 것이기 때문입니다.

즉, 도메인(비즈니스) 로직이라고 말할 때는 현실 세상의 문제를 해결하는 소스코드를 의미합니다.

## 애플리케이션 서비스 로직

**개발자는 특정 문제 영역에 대한 솔류션을 제공하는 코드 외에도 많은 소스코드를 작성해야 합니다. 예를 들면, 비즈니스 로직을 담고 있는 소스코드를 동작할 수 있게 만들고 입출력을 처리하기 위한 로직들이 있을 수 있습니다. 대표적으로는 데이터베이스에 연결하고 사용자와 인터렉션하는 소스코드 등이 있을 수 있습니다.**

이런 부분들은 도메인 로직과 구분해서 `애플리케이션 서비스 로직`이라고 부릅니다.

## A라는 코드는 현실 문제에 대한 의사결정을 하고 있어요?

결국 도메인 로직과 서비스 로직을 구분하는 척도는 `비즈니스 의사결정의 유무` 입니다. 해당 문장만 보면 잘 감이 안올 수 있는데, 예를 같이 들어보겠습니다.

### 모바일 송금 예시

송금 기능을 담당하는 소스코드가 있다고 가정하겠습니다.

> [!NOTE]
>
> -   계좌 잔액이 충분한지 확인
> -   유효하다면 송금 버튼을 활성화하고, 유효하지 않다면 에러 메세지를 출력한다
> -   사용자의 멤버십 등급에 맞춰서 송금 수수료를 계산합니다
> -   송금 수수료를 결제하도록 외부 결제 서비스에 요청합니다
> -   사용자의 잔액을 감소시킵니다
> -   사용자의 잔액을 DB에 저장합니다

-   `"송금"` 이라는 현실 문제에 대한 의사결정을 하는 로직은 어떤 것일까요? 도메인 로직에 해당하는 것은 `(1),(3),(5)` 입니다.
    -   (1): 송금이 가능한지에 대한 의사결정
    -   (3): 송금에 드는 비용을 정책에 따라서 결정
    -   (5): 송금이라는 서비스를 수행
-   반대로 서비스 로직에 해당하는 것은 `(2),(4),(6)` 입니다.
    -   (2): UI
    -   (4): 외부 서비스와의 네트워킹
    -   (6): Persistence

## 왜 이렇게 구분을 하는거야?

-   결국 우리가 나누는 이유는 `관심사의 분리` 때문입니다. 도메인 로직과 서비스 로직은 어떤 앱이든 구분되고 변경의 이유도 다르기 때문입니다.
-   도메인 로직과 아닌 것을 잘 나누고 결합도를 낮추게 되면 로직을 이해하기 쉬워집니다.

---

## Google Gemini에게 물어본 답변

해당 답변도 어느정도 이해가 되어서 같이 첨부해보려고 합니다. 아래는 제가 직접 작성한 프롬프트 내용입니다.

```
비즈니스 로직이란 무엇인가요? 그리고 도메인 로직이라는 단어도 들어봤는데 둘의 차이를 잘 모르겠습니다. 이해하기 쉬운 예시를 통해서 설명해주세요!
```

### 비즈니스 로직과 도메인 로직: 핵심 개념 이해하기

-   도메인 로직은 비즈니스 로직의 한 종류라고 할 수 있습니다. 넓은 의미의 비즈니스 로직 안에 도메인 로직이 포함되는 개념입니다.
-   아키텍처를 설계할 때는 이 둘을 구분해서 역할과 책임을 명확히 하는 것이 중요하다고 합니다.

### 비즈니스 로직 (Business Logic)

**소프트웨어가 특정 비즈니스 목표를 달성하기 위해 수행하는 모든 규칙과 연산을 포괄하는 광범위한 개념입니다. 사용자의 요구사항을 만족시키기 위해 시스템이 해야하는 모든 행위를 의미합니다.**

```
< 예시 (회원가입 과정에서) >

- 이메일 중복 검사: "회원가입 시 동일한 이메일로 이미 가입된 회원이 있으면 안 된다." (다른 회원의 존재 여부를 DB에서 확인해야 하므로 외부 의존성을 가짐)
- 닉네임 중복 검사: "닉네임은 다른 사용자와 중복될 수 없다." (마찬가지로 DB 확인 필요)
- 비밀번호 암호화: "사용자 비밀번호는 보안을 위해 저장 시 암호화되어야 한다." (기술적인 결정이 포함됨)
- Display ID 부여: "새로운 사용자에게는 'U0000001'과 같은 고유한 고객 식별 번호가 자동으로 부여되어야 한다." (시퀀스 관리 시스템과 연동 필요)
- 토큰 발급: "회원가입이 완료되면 해당 사용자에게 서비스 이용을 위한 Access/Refresh 토큰을 발급해야 한다." (보안 및 인증 시스템과 연동 필요)
- 이메일 형식 검증: "이메일은 @를 포함하는 올바른 형식이어야 한다." (어떤 계층이든 처리할 수 있는 기본적인 규칙)
```

위 내용이 회원가입이라는 비즈니스 목표를 달성하기 위한 규칙과 처리 절차이기 때문에 넓은 의미의 비즈니스 로직이라고 할 수 있습니다.

### 도메인 로직 (Domain Logic)

-   특정 도메인(현실 세계의 비즈니스 영역)의 핵심 개념과 그들 간의 관계에서 발생하는 규칙과 행위를 의미합니다.
-   특히 자신이 표현하는 도메인 객체인 Entity 내부에서 스스로의 상태를 관리하고 유효성을 보장하는 로직을 주로 지칭합니다.
-   도메인 로직은 일반적으로는 다른 외부 시스템(데이터베이스, 외부API 등)에 대한 직접적인 의존성을 가지지 않으려고 합니다.

```
< 예시 (회원가입 과정에서) >

- UserEntity 내의 비밀번호 암호화/비교: "User 객체는 자신의 비밀번호를 안전하게 저장하고, 평문 비밀번호가 주어졌을 때 자신의 저장된 비밀번호와 일치하는지 스스로 검증할 수 있어야 한다." (UserEntity.createNew()에서 평문 비밀번호를 해싱하고, UserEntity.comparePassword()에서 비교)

- UserEntity 내의 닉네임 변경 규칙: "User 객체의 닉네임을 변경할 때, 새 닉네임은 최소 2자 이상이어야 한다." (UserEntity.updateNickname() 메서드 내부의 유효성 검증)

- DisplayIdEntity 내의 다음 시퀀스 생성: "Display ID 객체는 자신의 시퀀스를 증가시켜 새로운 유효한 Display ID를 생성할 수 있어야 한다." (DisplayIdEntity.generateAndSetNextUserSeqDisplayId()에서 시퀀스 값을 관리하고 포맷팅하는 부분)
```

**핵심은 도메인 로직은 "내가 어떤 상태에 있을 때 나에게 어떤 행동을 하면 내가 어떻게 변해야 한다" 또는 "내가 어떤 상태에 있을 때 나는 어떤 조건을 만족해야 유효하다"와 같이 객체 스스로가 자신의 비즈니스 규칙을 표현하고 지키는 것에 가깝습니다.**

### 이해하기 쉬운 예시: 은행 계좌 이체

```
< A 계좌에서 B 계좌로 10만원을 이체 >

비즈니스 로직 (전체 프로세스):

- A 계좌의 잔액이 10만원보다 많은지 확인한다. (DB 조회)
- 만약 잔액이 부족하면 "잔액 부족" 메시지를 띄운다.
- 이체 수수료를 계산한다. (사용자 등급, 정책에 따라 달라짐)
- 수수료를 포함한 최종 금액을 A 계좌에서 차감한다. (DB 업데이트)
- B 계좌에 최종 금액을 입금한다. (DB 업데이트)
- 이체 내역을 기록한다. (DB 저장)
- A 계좌 사용자에게 "이체 완료" 알림을 보낸다. (외부 알림 시스템 연동)

이 모든 과정은 '계좌 이체'라는 비즈니스를 완성하는 데 필요한 규칙과 절차이므로 넓은 의미의 비즈니스 로직입니다. 보통 서비스 계층에서 이런 전체적인 흐름을 오케스트레이션(조율)합니다.

도메인 로직 (핵심 규칙과 객체의 행위):

Account (계좌) 객체:

-   Account.withdraw(amount): "내 계좌에서 amount만큼 출금할 때, 내 현재 잔액이 amount보다 적으면 InsufficientFundsException을 발생시킨다. 아니면 잔액을 감소시킨다." (잔액 부족 여부 판단 및 잔액 변경)

-   Account.deposit(amount): "내 계좌에 amount만큼 입금할 때, 잔액을 증가시킨다." (잔액 변경)

Transaction (거래) 객체:

-   Transaction.create(fromAccount, toAccount, amount, fee): "유효한 송금 계좌와 수취 계좌, 그리고 금액과 수수료가 주어졌을 때, 거래 내역을 기록하는 객체를 생성한다."
    여기서 Account.withdraw()는 자신의 상태(잔액)를 변경하고 그 유효성을 스스로 검증하는 도메인 로직입니다. 이 로직은 "어떤 계좌의 잔액이 얼마인지"에 대한 정보만 있으면 되고, 다른 계좌가 어디 있는지, DB에 어떻게 저장되는지 등은 알 필요가 없습니다.

요약 및 적용 지점

비즈니스 로직: 소프트웨어 전체가 달성해야 하는 목표와 관련된 모든 규칙과 절차. (주로 Service 계층에서 이 전체적인 흐름을 관리하고, 여러 도메인 객체, Repository, 외부 시스템을 조율하며 구현됨)

도메인 로직: 특정 도메인 객체(Entity)가 스스로의 상태와 유효성을 관리하는 데 필요한 핵심 규칙과 행위. 외부 의존성(특히 영속성)을 최소화하려고 노력함. (주로 도메인 계층의 Entity 또는 Value Object 내부에 구현됨)

따라서 회원가입 예시에서:

**UserService**는 비즈니스 로직을 담당합니다. (이메일/닉네임 중복 검사 (DB 접근 필요), UserEntity 생성 조율, DisplayId 생성 및 할당 조율, 토큰 발급 조율 등)

**UserEntity**는 도메인 로직을 담당합니다. (자신의 비밀번호를 암호화하고 비교하는 로직, 닉네임 변경 시 유효성 검사, displayId를 할당받는 로직 등)

**DisplayIdEntity**도 도메인 로직을 가집니다. (자신의 시퀀스를 관리하고 다음 유효한 DisplayId를 생성하는 로직)

이렇게 각자의 역할을 명확히 분리함으로써, 코드를 더 이해하기 쉽고, 테스트하기 용이하며, 유지보수와 확장에 유리한 구조를 만들 수 있습니다.
```
