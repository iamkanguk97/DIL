# 챕터1: 리팩터링: 첫 번째 예시

**대규모 시스템의 소스코드는 리팩터링을 하고 안하고의 차이가 큽니다. 그렇기 때문에 이번 장에서 첨부된 리팩토링 과정을 잘 학습해놓아야 합니다.**

## 예시 프로그램 작성 및 소감

> 예시 프로그램은 `example` 디렉토리에 첨부되어 있습니다.

> [!IMPORTANT]
>
> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가합니다.

## 리팩터링의 첫 단계

**리팩터링의 첫 단계는 항상 리팩터링할 코드 영역을 꼼꼼하게 검사하는 `테스트 코드`를 마련해야 합니다**. 실제 작업을 사람이 수행하기 때문에 오류가 발생할 가능성이 있는데 이를 테스트 코드를 통해 커버합니다.

만약 해당 예제에서 테스트 코드를 작성한다면 시나리오는 아래와 같을 겁니다.

> [!NOTE]
>
> - statement 함수는 문자열을 반환하기 때문에 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성해서 문자열 형태로 구성합니다.
> - statement 함수가 반환한 문자열 결과와 준비해둔 정답 문자열을 비교합니다.
> - 테스트 프레임워크를 사용해서 모든 테스트를 단축키 하나로 실행할 수 있도록 설정합니다.

## statement 함수 쪼개기

> [!IMPORTANT]
>
> - 항상 수정을 하면 컴파일하고 테스트해서 실수한게 없는지 확인해야 합니다.
> - 간단한 수정이라도 리팩터링 후에는 테스트하는 습관을 들이는 것이 바람직합니다.

### (1) switch 문 쪼개기

- switch문은 현재 한 번의 공연에 대한 요금을 계산하고 있습니다.
- `함수 추출하기`: 함수를 하나 구성해서 사용하는 방식으로 리팩터링을 진행합니다.
- 별도 함수로 뺐을 때 유효범위를 벗어나는 변수, 즉 새 함수에서는 곧바로 상요할 수 없는 변수가 있는지 확인해야 합니다. 여기서는 `perf, play, thisAmount`가 속합니다.
- `perf`와 `play`는 변하는 값이 아니기 때문에 매개변수로 전달합니다.
- 이와 다르게 `thisAmount`는 특정 로직에 따라 값이 변경되기 때문에 조심해서 다루면 됩니다.
- `중첩함수(Nested Function)`를 사용해서 만들 수도 있다. 중첩 함수를 만들면 할일 하나가 줄어드는 셈이다.
  - 다만, `2-2.js`에서와 같이 for문 안에서 선언된 변수여서 중첩함수가 접근할 수 없습니다.
  - 이렇게 되면 중첩함수를 사용하거나 안하거나 차이점이 없습니다.

