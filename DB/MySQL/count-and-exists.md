# MySQL COUNT와 EXISTS 함수 성능 비교

## 목차

1. [개요](#개요)
2. [COUNT 함수](#count-함수)
3. [EXISTS 함수](#exists-함수)
4. [사전 준비사항](#사전-준비사항)
    - [테스트 환경](#테스트-환경)
    - [테이블 생성](#테이블-생성)
    - [데이터 삽입](#데이터-삽입)
5. [테스트 진행](#테스트-진행)
    - [조건을 만족하는 행이 많은 경우](#조건을-만족하는-행이-많은-경우)
    - [조건을 만족하는 행이 적은 경우](#조건을-만족하는-행이-적은-경우)
6. [결과 해석](#결과-해석)
    - [성능 비교 요약](#성능-비교-요약)
    - [성능 차이의 원인](#성능-차이의-원인)
7. [결론 및 권장사항](#결론-및-권장사항)
    - [언제 EXISTS를 사용해야 할까?](#언제-exists를-사용해야-할까)
    - [언제 COUNT를 사용해야 할까?](#언제-count를-사용해야-할까)
8. [추가적인 최적화 방법](#추가적인-최적화-방법)
    - [Index 적용](#index-적용)
    - [불필요한 조회 컬럼 제거 (EXISTS)](#불필요한-조회-컬럼-제거-exists)

---

## 개요

> [!NOTE]
>
> -   회사 후임분 코드리뷰 중 COUNT 메서드를 사용하는 부분이 보였는데 EXISTS 메서드와 성능차이를 비교하는 블로그 포스팅을 본 게 생각이 들었습니다.
> -   그래서 로컬 데이터베이스에 대용량의 데이터를 저장해서 직접 성능차이를 비교해보려고 합니다.

`회원가입 API`를 수행할 때 이메일 기반으로 회원가입을 한다고 한다면 Request로 들어온 이메일에 대해서 중복 확인을 해야합니다. 이 때 중복확인 쿼리를 어떤식으로 작성할건지에 대해서 고민을 해보게 되었습니다.

## COUNT 함수

```sql
SELECT COUNT(*)
FROM users
WHERE active = 1;
```

-   `COUNT`는 **테이블에서 특정 조건을 만족하는 행의 개수를 반환**합니다. 모든 행을 스캔해서 개수를 세는 방식으로 결과를 얻습니다.
-   단순 개수 확인을 위해서는 유용하지만 데이터셋의 크기가 클 경우 성능 저하가 발생할 수 있습니다.

## EXISTS 함수

```sql
SELECT EXISTS(SELECT 1 FROM users WHERE active = 1);
```

-   `EXISTS`는 **조건을 만족하는 행이 있는지 여부만을 판단**하는 함수입니다.
-   **첫 번째로 조건을 만족하는 행을 찾으면 즉시 쿼리를 종료하기 때문에 COUNT 보다 성능이 뛰어날** 수 있습니다.

## 사전 준비사항

### 테스트 환경

-   MySQL 8.0
-   2024 MacBook Air M3
-   16GB RAM

### 테이블 생성

```sql
CREATE TABLE order_details (
    detail_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    product_id INT,
    quantity INT,
    price_per_unit DECIMAL(10, 2),
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,
    INDEX idx_order_id (order_id)
);
```

`Google Gemini`를 통해서 아무 테이블을 하나 생성했습니다.

### 데이터 삽입

-   약 `300만` 건의 데이터를 삽입했습니다.
-   `LLM`을 통해 **Batch Insert 스크립트를 Python으로 생성하여 삽입**을 진행했습니다.

## 테스트 진행

> 테스트는 조건을 만족하는 행이 적은 경우와 많은 경우로 나눠서 진행합니다.

### 조건을 만족하는 행이 많은 경우

> `quantity`가 2 이상인 ROW가 `order_details` 테이블의 약 90%를 차지합니다.

```sql
SELECT COUNT(*) FROM order_details WHERE quantity >= 2;
SELECT EXISTS(SELECT 1 FROM order_details WHERE quantity >= 2);
```

-   `COUNT` 함수 사용: `332ms`
-   `EXISTS` 함수 사용: `6.9ms`

### 조건을 만족하는 행이 적은 경우

> `quantity`가 2 이상인 ROW가 `order_details` 테이블의 약 10%를 차지합니다.

```sql
SELECT COUNT(*) FROM order_details WHERE quantity < 2;
SELECT EXISTS(SELECT 1 FROM order_details WHERE quantity < 2);
```

-   `COUNT` 함수 사용: `292ms`
-   `EXISTS` 함수 사용: `175ms`

## 결과 해석

### 성능 비교 요약

| 시나리오                       | COUNT 함수 | EXISTS 함수 | 성능 차이         |
| ------------------------------ | ---------- | ----------- | ----------------- |
| 조건 만족 행이 많은 경우 (90%) | 332ms      | 6.9ms       | **약 48배 빠름**  |
| 조건 만족 행이 적은 경우 (10%) | 292ms      | 175ms       | **약 1.7배 빠름** |

### 성능 차이의 원인

1. **COUNT 함수의 동작 방식**

    - 조건을 만족하는 **모든 행을 스캔**하여 개수를 계산합니다.
    - 데이터가 많든 적든 상관없이 테이블 전체를 스캔해야 하므로 일정한 시간이 소요됩니다.
    - 위 테스트에서 조건을 만족하는 행이 많은 경우(332ms)와 적은 경우(292ms) 모두 비슷한 실행 시간을 보였습니다.

2. **EXISTS 함수의 동작 방식**

    - 조건을 만족하는 **첫 번째 행을 찾으면 즉시 종료**합니다.
    - 조건을 만족하는 행이 많을 때는 매우 빠르게 첫 번째 행을 찾아 종료하므로 극적인 성능 향상을 보였습니다 (6.9ms).
    - 하지만 조건을 만족하는 행이 적을 때는 더 많은 행을 스캔해야 하므로 상대적으로 시간이 오래 걸렸습니다 (175ms).
        - 확인해보니 `quantity`가 1인 ROW의 첫 ID가 `2000000(200만)` 이었습니다.
        - 이는 2백만 전의 ID를 다 확인한 후에 2백만번 째 ID를 만났을 때 쿼리가 종료되었다는 의미입니다.

## 결론 및 권장사항

### 언제 EXISTS를 사용해야 할까?

> [!IMPORTANT]
>
> 아무래도 함수 이름과 동일하게 `어떤 데이터가 존재하는지에 대해 확인`하는 함수이기 때문에 해당 요구사항을 만족해야 할 때 사용하면 좋을 것 같습니다.

### 언제 COUNT를 사용해야 할까?

> [!IMPORTANT]
>
> -   정확한 개수가 필요할 때는 어쩔 수 없이 COUNT를 사용해야 합니다 (물론 기본이 되는 테이블의 컬럼에 개수 정보를 저장할 수 있습니다)
> -   데이터가 적은 경우에는 성능차이가 크지 않기 때문에 사용해도 괜찮습니다.

## 추가적인 최적화 방법

### Index 적용

-   따로 설명을 하지는 않겠습니다.
-   당연히 Index를 적용하면서 조회 속도가 개선되고 그에 따라 `COUNT` 및 `EXISTS` 함수 모두 개선될 것입니다.

### 불필요한 조회 컬럼 제거 (EXISTS)

```sql
SELECT EXISTS(SELECT 1 FROM users WHERE email = 'test@example.com');
```

-   `EXISTS` 함수는 결과를 반환할 필요가 없습니다. 그렇기 때문에 불필요한 데이터를 조회하지 않도록 쿼리를 최소화한다면 성능이 더 좋아질 것입니다.
